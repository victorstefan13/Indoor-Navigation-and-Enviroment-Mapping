<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>Eigen-unsupported: Eigen Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css"   rel="stylesheet" type="text/css" />
<link href="eigendoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
<!-- <script type="text/javascript"> -->
<!-- </script> -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- <a name="top"></a> -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Eigen_Silly_Professor_64x64.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname"><a href="http://eigen.tuxfamily.org">Eigen-unsupported</a>
   &#160;<span id="projectnumber">3.2.10</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceEigen.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Eigen Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>iterative scaling algorithm to equilibrate rows and column norms in matrices  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1AutoDiffScalar.html">AutoDiffScalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scalar type replacement with automatic differentation capability.  <a href="classEigen_1_1AutoDiffScalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1BDCSVD.html">BDCSVD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class Bidiagonal Divide and Conquer SVD  <a href="classEigen_1_1BDCSVD.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DGMRES.html">DGMRES</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Restarted <a class="el" href="classEigen_1_1GMRES.html" title="A GMRES solver for sparse square problems. ">GMRES</a> with deflation. This class implements a modification of the <a class="el" href="classEigen_1_1GMRES.html" title="A GMRES solver for sparse square problems. ">GMRES</a> solver for sparse linear systems. The basis is built with modified Gram-Schmidt. At each restart, a few approximated eigenvectors corresponding to the smallest eigenvalues are used to build a preconditioner for the next cycle. This preconditioner for deflation can be combined with any other preconditioner, the IncompleteLUT for instance. The preconditioner is applied at right of the matrix and the combination is multiplicative.  <a href="classEigen_1_1DGMRES.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DynamicSparseMatrix.html">DynamicSparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse matrix class designed for matrix assembly purpose.  <a href="classEigen_1_1DynamicSparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1GMRES.html">GMRES</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classEigen_1_1GMRES.html" title="A GMRES solver for sparse square problems. ">GMRES</a> solver for sparse square problems.  <a href="classEigen_1_1GMRES.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1HybridNonLinearSolver.html">HybridNonLinearSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a zero of a system of n nonlinear functions in n variables by a modification of the Powell hybrid method ("dogleg").  <a href="classEigen_1_1HybridNonLinearSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1IncompleteCholesky.html">IncompleteCholesky</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modified Incomplete Cholesky with dual threshold.  <a href="classEigen_1_1IncompleteCholesky.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1IterationController.html">IterationController</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls the iterations of the iterative solvers.  <a href="classEigen_1_1IterationController.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1JacobiSVD.html">JacobiSVD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two-sided Jacobi SVD decomposition of a rectangular matrix.  <a href="classEigen_1_1JacobiSVD.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1KdBVH.html">KdBVH</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple bounding volume hierarchy based on AlignedBox.  <a href="classEigen_1_1KdBVH.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1KroneckerProduct.html">KroneckerProduct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker tensor product helper class for dense matrices.  <a href="classEigen_1_1KroneckerProduct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1KroneckerProductSparse.html">KroneckerProductSparse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker tensor product helper class for sparse matrices.  <a href="classEigen_1_1KroneckerProductSparse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1LevenbergMarquardt.html">LevenbergMarquardt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs non linear optimization over a non-linear function, using a variant of the Levenberg Marquardt algorithm.  <a href="classEigen_1_1LevenbergMarquardt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixExponential.html">MatrixExponential</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for computing the matrix exponential.  <a href="classEigen_1_1MatrixExponential.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1MatrixExponentialReturnValue.html">MatrixExponentialReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix exponential of some matrix (expression).  <a href="structEigen_1_1MatrixExponentialReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixFunction.html">MatrixFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for computing matrix functions.  <a href="classEigen_1_1MatrixFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixFunctionAtomic.html">MatrixFunctionAtomic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for computing matrix functions of atomic matrices.  <a href="classEigen_1_1MatrixFunctionAtomic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixFunctionReturnValue.html">MatrixFunctionReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix function of some matrix (expression).  <a href="classEigen_1_1MatrixFunctionReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixLogarithmAtomic.html">MatrixLogarithmAtomic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for computing matrix logarithm of atomic matrices.  <a href="classEigen_1_1MatrixLogarithmAtomic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixLogarithmReturnValue.html">MatrixLogarithmReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix logarithm of some matrix (expression).  <a href="classEigen_1_1MatrixLogarithmReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixMarketIterator.html">MatrixMarketIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to browse matrices from a specified folder.  <a href="classEigen_1_1MatrixMarketIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixPower.html">MatrixPower</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for computing matrix powers.  <a href="classEigen_1_1MatrixPower.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixPowerReturnValue.html">MatrixPowerReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix power of some matrix (expression).  <a href="classEigen_1_1MatrixPowerReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixSquareRoot.html">MatrixSquareRoot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for computing matrix square roots of general matrices.  <a href="classEigen_1_1MatrixSquareRoot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixSquareRootQuasiTriangular.html">MatrixSquareRootQuasiTriangular</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for computing matrix square roots of upper quasi-triangular matrices.  <a href="classEigen_1_1MatrixSquareRootQuasiTriangular.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixSquareRootReturnValue.html">MatrixSquareRootReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix square root of some matrix (expression).  <a href="classEigen_1_1MatrixSquareRootReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixSquareRootTriangular.html">MatrixSquareRootTriangular</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for computing matrix square roots of upper triangular matrices.  <a href="classEigen_1_1MatrixSquareRootTriangular.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MINRES.html">MINRES</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A minimal residual solver for sparse symmetric problems.  <a href="classEigen_1_1MINRES.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1NumericalDiff.html">NumericalDiff</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1PolynomialSolver.html">PolynomialSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A polynomial solver.  <a href="classEigen_1_1PolynomialSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1PolynomialSolverBase.html">PolynomialSolverBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined to be inherited by polynomial solvers: it provides convenient methods such as.  <a href="classEigen_1_1PolynomialSolverBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1RandomSetter.html">RandomSetter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classEigen_1_1RandomSetter.html" title="The RandomSetter is a wrapper object allowing to set/update a sparse matrix with random access...">RandomSetter</a> is a wrapper object allowing to set/update a sparse matrix with random access.  <a href="classEigen_1_1RandomSetter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SkylineInplaceLU.html">SkylineInplaceLU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace LU decomposition of a skyline matrix and associated features.  <a href="classEigen_1_1SkylineInplaceLU.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SkylineMatrix.html">SkylineMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main skyline matrix class.  <a href="classEigen_1_1SkylineMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SkylineMatrixBase.html">SkylineMatrixBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of any skyline matrices or skyline expressions.  <a href="classEigen_1_1SkylineMatrixBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SkylineStorage.html">SkylineStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Spline.html">Spline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing multi-dimensional spline curves.  <a href="classEigen_1_1Spline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1SplineFitting.html">SplineFitting</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEigen_1_1Spline.html" title="A class representing multi-dimensional spline curves. ">Spline</a> fitting methods.  <a href="structEigen_1_1SplineFitting.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1SplineTraits_3_01Spline_3_01__Scalar_00_01__Dim_00_01__Degree_01_4_00_01__DerivativeOrder_01_4.html">SplineTraits&lt; Spline&lt; _Scalar, _Dim, _Degree &gt;, _DerivativeOrder &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time attributes of the <a class="el" href="classEigen_1_1Spline.html" title="A class representing multi-dimensional spline curves. ">Spline</a> class for fixed degree.  <a href="structEigen_1_1SplineTraits_3_01Spline_3_01__Scalar_00_01__Dim_00_01__Degree_01_4_00_01__DerivativeOrder_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1SplineTraits_3_01Spline_3_01__Scalar_00_01__Dim_00_01__Degree_01_4_00_01Dynamic_01_4.html">SplineTraits&lt; Spline&lt; _Scalar, _Dim, _Degree &gt;, Dynamic &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time attributes of the <a class="el" href="classEigen_1_1Spline.html" title="A class representing multi-dimensional spline curves. ">Spline</a> class for Dynamic degree.  <a href="structEigen_1_1SplineTraits_3_01Spline_3_01__Scalar_00_01__Dim_00_01__Degree_01_4_00_01Dynamic_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1StdMapTraits.html">StdMapTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1StdStemFunctions.html">StdStemFunctions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stem functions corresponding to standard mathematical functions.  <a href="classEigen_1_1StdStemFunctions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SVDBase.html">SVDBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mother class of SVD classes algorithms.  <a href="classEigen_1_1SVDBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac873daea7b3a9b6b8f7871c870d2ebe6"><td class="memItemLeft" align="right" valign="top"><a id="ac873daea7b3a9b6b8f7871c870d2ebe6"></a>
typedef <a class="el" href="classEigen_1_1Spline.html">Spline</a>&lt; double, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#ac873daea7b3a9b6b8f7871c870d2ebe6">Spline2d</a></td></tr>
<tr class="memdesc:ac873daea7b3a9b6b8f7871c870d2ebe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D double B-spline with dynamic degree. <br /></td></tr>
<tr class="separator:ac873daea7b3a9b6b8f7871c870d2ebe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd2c65ab58ac9650d544d48eb9b344f"><td class="memItemLeft" align="right" valign="top"><a id="a1bd2c65ab58ac9650d544d48eb9b344f"></a>
typedef <a class="el" href="classEigen_1_1Spline.html">Spline</a>&lt; float, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a1bd2c65ab58ac9650d544d48eb9b344f">Spline2f</a></td></tr>
<tr class="memdesc:a1bd2c65ab58ac9650d544d48eb9b344f"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D float B-spline with dynamic degree. <br /></td></tr>
<tr class="separator:a1bd2c65ab58ac9650d544d48eb9b344f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe16609b15ce4504173a6eaabe900f35"><td class="memItemLeft" align="right" valign="top"><a id="afe16609b15ce4504173a6eaabe900f35"></a>
typedef <a class="el" href="classEigen_1_1Spline.html">Spline</a>&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#afe16609b15ce4504173a6eaabe900f35">Spline3d</a></td></tr>
<tr class="memdesc:afe16609b15ce4504173a6eaabe900f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D double B-spline with dynamic degree. <br /></td></tr>
<tr class="separator:afe16609b15ce4504173a6eaabe900f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ab6860f203ce6726ddc9522b2826e9"><td class="memItemLeft" align="right" valign="top"><a id="a39ab6860f203ce6726ddc9522b2826e9"></a>
typedef <a class="el" href="classEigen_1_1Spline.html">Spline</a>&lt; float, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a39ab6860f203ce6726ddc9522b2826e9">Spline3f</a></td></tr>
<tr class="memdesc:a39ab6860f203ce6726ddc9522b2826e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D float B-spline with dynamic degree. <br /></td></tr>
<tr class="separator:a39ab6860f203ce6726ddc9522b2826e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a07d8e283f082c972338f3fc4f644b2a9"><td class="memTemplParams" colspan="2">template&lt;typename BVH , typename Intersector &gt; </td></tr>
<tr class="memitem:a07d8e283f082c972338f3fc4f644b2a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a07d8e283f082c972338f3fc4f644b2a9">BVIntersect</a> (const BVH &amp;tree, Intersector &amp;intersector)</td></tr>
<tr class="separator:a07d8e283f082c972338f3fc4f644b2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b8047a3ee05b5e6fec4668197a9a43"><td class="memTemplParams" colspan="2">template&lt;typename BVH1 , typename BVH2 , typename Intersector &gt; </td></tr>
<tr class="memitem:ac3b8047a3ee05b5e6fec4668197a9a43"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#ac3b8047a3ee05b5e6fec4668197a9a43">BVIntersect</a> (const BVH1 &amp;tree1, const BVH2 &amp;tree2, Intersector &amp;intersector)</td></tr>
<tr class="separator:ac3b8047a3ee05b5e6fec4668197a9a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbe73ac1482eacab0e18ee32c25508e"><td class="memTemplParams" colspan="2">template&lt;typename BVH , typename Minimizer &gt; </td></tr>
<tr class="memitem:adcbe73ac1482eacab0e18ee32c25508e"><td class="memTemplItemLeft" align="right" valign="top">Minimizer::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#adcbe73ac1482eacab0e18ee32c25508e">BVMinimize</a> (const BVH &amp;tree, Minimizer &amp;minimizer)</td></tr>
<tr class="separator:adcbe73ac1482eacab0e18ee32c25508e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915f6adc8b195c94a83c35de6a842556"><td class="memTemplParams" colspan="2">template&lt;typename BVH1 , typename BVH2 , typename Minimizer &gt; </td></tr>
<tr class="memitem:a915f6adc8b195c94a83c35de6a842556"><td class="memTemplItemLeft" align="right" valign="top">Minimizer::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a915f6adc8b195c94a83c35de6a842556">BVMinimize</a> (const BVH1 &amp;tree1, const BVH2 &amp;tree2, Minimizer &amp;minimizer)</td></tr>
<tr class="separator:a915f6adc8b195c94a83c35de6a842556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375e3ea1f370fb76dfe0f43a89b95926"><td class="memTemplParams" colspan="2">template&lt;typename Polynomial &gt; </td></tr>
<tr class="memitem:a375e3ea1f370fb76dfe0f43a89b95926"><td class="memTemplItemLeft" align="right" valign="top">NumTraits&lt; typename Polynomial::Scalar &gt;::Real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a375e3ea1f370fb76dfe0f43a89b95926">cauchy_max_bound</a> (const Polynomial &amp;poly)</td></tr>
<tr class="separator:a375e3ea1f370fb76dfe0f43a89b95926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab076afbdba0e9298a541cc4e8cc7506b"><td class="memTemplParams" colspan="2">template&lt;typename Polynomial &gt; </td></tr>
<tr class="memitem:ab076afbdba0e9298a541cc4e8cc7506b"><td class="memTemplItemLeft" align="right" valign="top">NumTraits&lt; typename Polynomial::Scalar &gt;::Real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#ab076afbdba0e9298a541cc4e8cc7506b">cauchy_min_bound</a> (const Polynomial &amp;poly)</td></tr>
<tr class="separator:ab076afbdba0e9298a541cc4e8cc7506b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4cbde5d98411405871accf877552d2"><td class="memTemplParams" colspan="2">template&lt;typename PointArrayType , typename KnotVectorType &gt; </td></tr>
<tr class="memitem:a1b4cbde5d98411405871accf877552d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a1b4cbde5d98411405871accf877552d2">ChordLengths</a> (const PointArrayType &amp;pts, KnotVectorType &amp;chord_lengths)</td></tr>
<tr class="memdesc:a1b4cbde5d98411405871accf877552d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes chord length parameters which are required for spline interpolation.  <a href="#a1b4cbde5d98411405871accf877552d2">More...</a><br /></td></tr>
<tr class="separator:a1b4cbde5d98411405871accf877552d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9474da5ed68bbd9a6788a999330416d6"><td class="memTemplParams" colspan="2">template&lt;typename KnotVectorType &gt; </td></tr>
<tr class="memitem:a9474da5ed68bbd9a6788a999330416d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a9474da5ed68bbd9a6788a999330416d6">KnotAveraging</a> (const KnotVectorType &amp;parameters, DenseIndex degree, KnotVectorType &amp;knots)</td></tr>
<tr class="memdesc:a9474da5ed68bbd9a6788a999330416d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes knot averages.The knots are computed as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} u_0 &amp; = \hdots = u_p = 0 \\ u_{m-p} &amp; = \hdots = u_{m} = 1 \\ u_{j+p} &amp; = \frac{1}{p}\sum_{i=j}^{j+p-1}\bar{u}_i \quad\quad j=1,\hdots,n-p \end{align*}" src="form_37.png"/>
</p>
<p> where <img class="formulaInl" alt="$p$" src="form_34.png"/> is the degree and <img class="formulaInl" alt="$m+1$" src="form_38.png"/> the number knots of the desired interpolating spline.  <a href="#a9474da5ed68bbd9a6788a999330416d6">More...</a><br /></td></tr>
<tr class="separator:a9474da5ed68bbd9a6788a999330416d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8924dffc6cee7aa1e908dc395a7a167"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:aa8924dffc6cee7aa1e908dc395a7a167"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1KroneckerProduct.html">KroneckerProduct</a>&lt; A, B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#aa8924dffc6cee7aa1e908dc395a7a167">kroneckerProduct</a> (const MatrixBase&lt; A &gt; &amp;a, const MatrixBase&lt; B &gt; &amp;b)</td></tr>
<tr class="separator:aa8924dffc6cee7aa1e908dc395a7a167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca497f43cc92bcbf6eaff64984a266cc"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:aca497f43cc92bcbf6eaff64984a266cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1KroneckerProductSparse.html">KroneckerProductSparse</a>&lt; A, B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#aca497f43cc92bcbf6eaff64984a266cc">kroneckerProduct</a> (const EigenBase&lt; A &gt; &amp;a, const EigenBase&lt; B &gt; &amp;b)</td></tr>
<tr class="separator:aca497f43cc92bcbf6eaff64984a266cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb64ffddaa9e83634e3ab0e3fd3664f5"><td class="memTemplParams" colspan="2">template&lt;typename Polynomials , typename T &gt; </td></tr>
<tr class="memitem:adb64ffddaa9e83634e3ab0e3fd3664f5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#adb64ffddaa9e83634e3ab0e3fd3664f5">poly_eval</a> (const Polynomials &amp;poly, const T &amp;x)</td></tr>
<tr class="separator:adb64ffddaa9e83634e3ab0e3fd3664f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbf059bc28ce1cf94c57c1454633d40"><td class="memTemplParams" colspan="2">template&lt;typename Polynomials , typename T &gt; </td></tr>
<tr class="memitem:aadbf059bc28ce1cf94c57c1454633d40"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#aadbf059bc28ce1cf94c57c1454633d40">poly_eval_horner</a> (const Polynomials &amp;poly, const T &amp;x)</td></tr>
<tr class="separator:aadbf059bc28ce1cf94c57c1454633d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc3648f7ef67db3d5d04454fc1257fd"><td class="memTemplParams" colspan="2">template&lt;typename RootVector , typename Polynomial &gt; </td></tr>
<tr class="memitem:afbc3648f7ef67db3d5d04454fc1257fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#afbc3648f7ef67db3d5d04454fc1257fd">roots_to_monicPolynomial</a> (const RootVector &amp;rv, Polynomial &amp;poly)</td></tr>
<tr class="separator:afbc3648f7ef67db3d5d04454fc1257fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>iterative scaling algorithm to equilibrate rows and column norms in matrices </p>
<p>This class can be used as a preprocessing tool to accelerate the convergence of iterative methods</p>
<p>This feature is useful to limit the pivoting amount during LU/ILU factorization The scaling strategy as presented here preserves the symmetry of the problem NOTE It is assumed that the matrix does not have empty row or column,</p>
<p>Example with key steps </p><div class="fragment"><div class="line">VectorXd x(n), b(n);</div><div class="line">SparseMatrix&lt;double&gt; A;</div><div class="line"><span class="comment">// fill A and b;</span></div><div class="line">IterScaling&lt;SparseMatrix&lt;double&gt; &gt; scal; </div><div class="line"><span class="comment">// Compute the left and right scaling vectors. The matrix is equilibrated at output</span></div><div class="line">scal.computeRef(A); </div><div class="line"><span class="comment">// Scale the right hand side</span></div><div class="line">b = scal.LeftScaling().cwiseProduct(b); </div><div class="line"><span class="comment">// Now, solve the equilibrated linear system with any available solver</span></div><div class="line"></div><div class="line"><span class="comment">// Scale back the computed solution</span></div><div class="line">x = scal.RightScaling().cwiseProduct(x); </div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_MatrixType</td><td>the type of the matrix. It should be a real square sparsematrix</td></tr>
  </table>
  </dd>
</dl>
<p>References : D. Ruiz and B. Ucar, A Symmetry Preserving Algorithm for Matrix Scaling, INRIA Research report RR-7552</p>
<dl class="section see"><dt>See also</dt><dd>IncompleteLUT </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a07d8e283f082c972338f3fc4f644b2a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d8e283f082c972338f3fc4f644b2a9">&#9670;&nbsp;</a></span>BVIntersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::BVIntersect </td>
          <td>(</td>
          <td class="paramtype">const BVH &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Intersector &amp;&#160;</td>
          <td class="paramname"><em>intersector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a BVH, runs the query encapsulated by <em>intersector</em>. The Intersector type must provide the following members:</p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> intersectVolume(<span class="keyword">const</span> BVH::Volume &amp;volume) <span class="comment">//returns true if volume intersects the query</span></div><div class="line"><span class="keywordtype">bool</span> intersectObject(<span class="keyword">const</span> BVH::Object &amp;<span class="keywordtype">object</span>) <span class="comment">//returns true if the search should terminate immediately</span></div></div><!-- fragment --> 
</div>
</div>
<a id="ac3b8047a3ee05b5e6fec4668197a9a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b8047a3ee05b5e6fec4668197a9a43">&#9670;&nbsp;</a></span>BVIntersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::BVIntersect </td>
          <td>(</td>
          <td class="paramtype">const BVH1 &amp;&#160;</td>
          <td class="paramname"><em>tree1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BVH2 &amp;&#160;</td>
          <td class="paramname"><em>tree2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Intersector &amp;&#160;</td>
          <td class="paramname"><em>intersector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given two BVH's, runs the query on their Cartesian product encapsulated by <em>intersector</em>. The Intersector type must provide the following members:</p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> intersectVolumeVolume(<span class="keyword">const</span> BVH1::Volume &amp;v1, <span class="keyword">const</span> BVH2::Volume &amp;v2) <span class="comment">//returns true if product of volumes intersects the query</span></div><div class="line"><span class="keywordtype">bool</span> intersectVolumeObject(<span class="keyword">const</span> BVH1::Volume &amp;v1, <span class="keyword">const</span> BVH2::Object &amp;o2) <span class="comment">//returns true if the volume-object product intersects the query</span></div><div class="line"><span class="keywordtype">bool</span> intersectObjectVolume(<span class="keyword">const</span> BVH1::Object &amp;o1, <span class="keyword">const</span> BVH2::Volume &amp;v2) <span class="comment">//returns true if the volume-object product intersects the query</span></div><div class="line"><span class="keywordtype">bool</span> intersectObjectObject(<span class="keyword">const</span> BVH1::Object &amp;o1, <span class="keyword">const</span> BVH2::Object &amp;o2) <span class="comment">//returns true if the search should terminate immediately</span></div></div><!-- fragment --> 
</div>
</div>
<a id="adcbe73ac1482eacab0e18ee32c25508e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcbe73ac1482eacab0e18ee32c25508e">&#9670;&nbsp;</a></span>BVMinimize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Minimizer::Scalar Eigen::BVMinimize </td>
          <td>(</td>
          <td class="paramtype">const BVH &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Minimizer &amp;&#160;</td>
          <td class="paramname"><em>minimizer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a BVH, runs the query encapsulated by <em>minimizer</em>. </p><dl class="section return"><dt>Returns</dt><dd>the minimum value. The Minimizer type must provide the following members:<div class="fragment"><div class="line"><span class="keyword">typedef</span> Scalar <span class="comment">//the numeric type of what is being minimized--not necessarily the Scalar type of the BVH (if it has one)</span></div><div class="line">Scalar minimumOnVolume(<span class="keyword">const</span> BVH::Volume &amp;volume)</div><div class="line">Scalar minimumOnObject(<span class="keyword">const</span> BVH::Object &amp;<span class="keywordtype">object</span>)</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a915f6adc8b195c94a83c35de6a842556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915f6adc8b195c94a83c35de6a842556">&#9670;&nbsp;</a></span>BVMinimize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Minimizer::Scalar Eigen::BVMinimize </td>
          <td>(</td>
          <td class="paramtype">const BVH1 &amp;&#160;</td>
          <td class="paramname"><em>tree1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BVH2 &amp;&#160;</td>
          <td class="paramname"><em>tree2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Minimizer &amp;&#160;</td>
          <td class="paramname"><em>minimizer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given two BVH's, runs the query on their cartesian product encapsulated by <em>minimizer</em>. </p><dl class="section return"><dt>Returns</dt><dd>the minimum value. The Minimizer type must provide the following members:<div class="fragment"><div class="line"><span class="keyword">typedef</span> Scalar <span class="comment">//the numeric type of what is being minimized--not necessarily the Scalar type of the BVH (if it has one)</span></div><div class="line">Scalar minimumOnVolumeVolume(<span class="keyword">const</span> BVH1::Volume &amp;v1, <span class="keyword">const</span> BVH2::Volume &amp;v2)</div><div class="line">Scalar minimumOnVolumeObject(<span class="keyword">const</span> BVH1::Volume &amp;v1, <span class="keyword">const</span> BVH2::Object &amp;o2)</div><div class="line">Scalar minimumOnObjectVolume(<span class="keyword">const</span> BVH1::Object &amp;o1, <span class="keyword">const</span> BVH2::Volume &amp;v2)</div><div class="line">Scalar minimumOnObjectObject(<span class="keyword">const</span> BVH1::Object &amp;o1, <span class="keyword">const</span> BVH2::Object &amp;o2)</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a375e3ea1f370fb76dfe0f43a89b95926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a375e3ea1f370fb76dfe0f43a89b95926">&#9670;&nbsp;</a></span>cauchy_max_bound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NumTraits&lt;typename Polynomial::Scalar&gt;::Real Eigen::cauchy_max_bound </td>
          <td>(</td>
          <td class="paramtype">const Polynomial &amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a maximum bound for the absolute value of any root of the polynomial.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poly</td><td>: the vector of coefficients of the polynomial ordered by degrees i.e. poly[i] is the coefficient of degree i of the polynomial e.g. <img class="formulaInl" alt="$ 1 + 3x^2 $" src="form_22.png"/> is stored as a vector <img class="formulaInl" alt="$ [ 1, 0, 3 ] $" src="form_23.png"/>.</td></tr>
  </table>
  </dd>
</dl>
<p><em><b>Precondition:</b></em>  the leading coefficient of the input polynomial poly must be non zero  </p>

</div>
</div>
<a id="ab076afbdba0e9298a541cc4e8cc7506b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab076afbdba0e9298a541cc4e8cc7506b">&#9670;&nbsp;</a></span>cauchy_min_bound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NumTraits&lt;typename Polynomial::Scalar&gt;::Real Eigen::cauchy_min_bound </td>
          <td>(</td>
          <td class="paramtype">const Polynomial &amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a minimum bound for the absolute value of any non zero root of the polynomial. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poly</td><td>: the vector of coefficients of the polynomial ordered by degrees i.e. poly[i] is the coefficient of degree i of the polynomial e.g. <img class="formulaInl" alt="$ 1 + 3x^2 $" src="form_22.png"/> is stored as a vector <img class="formulaInl" alt="$ [ 1, 0, 3 ] $" src="form_23.png"/>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b4cbde5d98411405871accf877552d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4cbde5d98411405871accf877552d2">&#9670;&nbsp;</a></span>ChordLengths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::ChordLengths </td>
          <td>(</td>
          <td class="paramtype">const PointArrayType &amp;&#160;</td>
          <td class="paramname"><em>pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KnotVectorType &amp;&#160;</td>
          <td class="paramname"><em>chord_lengths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes chord length parameters which are required for spline interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pts</td><td>The data points to which a spline should be fit. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">chord_lengths</td><td>The resulting chord lenggth vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>Les Piegl and Wayne Tiller, The NURBS book (2nd ed.), 1997, 9.2.1 Global Curve Interpolation to Point Data </dd></dl>

<p class="reference">Referenced by <a class="el" href="structEigen_1_1SplineFitting.html#adff4f85f223a278bc7ebae74e53a8441">SplineFitting&lt; SplineType &gt;::Interpolate()</a>.</p>

</div>
</div>
<a id="a9474da5ed68bbd9a6788a999330416d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9474da5ed68bbd9a6788a999330416d6">&#9670;&nbsp;</a></span>KnotAveraging()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::KnotAveraging </td>
          <td>(</td>
          <td class="paramtype">const KnotVectorType &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DenseIndex&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KnotVectorType &amp;&#160;</td>
          <td class="paramname"><em>knots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes knot averages.The knots are computed as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} u_0 &amp; = \hdots = u_p = 0 \\ u_{m-p} &amp; = \hdots = u_{m} = 1 \\ u_{j+p} &amp; = \frac{1}{p}\sum_{i=j}^{j+p-1}\bar{u}_i \quad\quad j=1,\hdots,n-p \end{align*}" src="form_37.png"/>
</p>
<p> where <img class="formulaInl" alt="$p$" src="form_34.png"/> is the degree and <img class="formulaInl" alt="$m+1$" src="form_38.png"/> the number knots of the desired interpolating spline. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameters</td><td>The input parameters. During interpolation one for each data point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degree</td><td>The spline degree which is used during the interpolation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">knots</td><td>The output knot vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>Les Piegl and Wayne Tiller, The NURBS book (2nd ed.), 1997, 9.2.1 Global Curve Interpolation to Point Data </dd></dl>

<p class="reference">Referenced by <a class="el" href="structEigen_1_1SplineFitting.html#a2a258a77c288288e364bb866814b991f">SplineFitting&lt; SplineType &gt;::Interpolate()</a>.</p>

</div>
</div>
<a id="aa8924dffc6cee7aa1e908dc395a7a167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8924dffc6cee7aa1e908dc395a7a167">&#9670;&nbsp;</a></span>kroneckerProduct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1KroneckerProduct.html">KroneckerProduct</a>&lt;A,B&gt; Eigen::kroneckerProduct </td>
          <td>(</td>
          <td class="paramtype">const MatrixBase&lt; A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixBase&lt; B &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes Kronecker tensor product of two dense matrices</p>
<dl class="section warning"><dt>Warning</dt><dd>If you want to replace a matrix by its Kronecker product with some matrix, do <b>NOT</b> do this: <div class="fragment"><div class="line">A = <a class="code" href="namespaceEigen.html#aa8924dffc6cee7aa1e908dc395a7a167">kroneckerProduct</a>(A,B); <span class="comment">// bug!!! caused by aliasing effect</span></div></div><!-- fragment --> instead, use eval() to work around this: <div class="fragment"><div class="line">A = <a class="code" href="namespaceEigen.html#aa8924dffc6cee7aa1e908dc395a7a167">kroneckerProduct</a>(A,B).eval();</div></div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Dense matrix a </td></tr>
    <tr><td class="paramname">b</td><td>Dense matrix b </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Kronecker tensor product of a and b </dd></dl>

</div>
</div>
<a id="aca497f43cc92bcbf6eaff64984a266cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca497f43cc92bcbf6eaff64984a266cc">&#9670;&nbsp;</a></span>kroneckerProduct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1KroneckerProductSparse.html">KroneckerProductSparse</a>&lt;A,B&gt; Eigen::kroneckerProduct </td>
          <td>(</td>
          <td class="paramtype">const EigenBase&lt; A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EigenBase&lt; B &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes Kronecker tensor product of two matrices, at least one of which is sparse</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Dense/sparse matrix a </td></tr>
    <tr><td class="paramname">b</td><td>Dense/sparse matrix b </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Kronecker tensor product of a and b, stored in a sparse matrix </dd></dl>

</div>
</div>
<a id="adb64ffddaa9e83634e3ab0e3fd3664f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb64ffddaa9e83634e3ab0e3fd3664f5">&#9670;&nbsp;</a></span>poly_eval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Eigen::poly_eval </td>
          <td>(</td>
          <td class="paramtype">const Polynomials &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the evaluation of the polynomial at x using stabilized Horner algorithm.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poly</td><td>: the vector of coefficients of the polynomial ordered by degrees i.e. poly[i] is the coefficient of degree i of the polynomial e.g. <img class="formulaInl" alt="$ 1 + 3x^2 $" src="form_22.png"/> is stored as a vector <img class="formulaInl" alt="$ [ 1, 0, 3 ] $" src="form_23.png"/>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: the value to evaluate the polynomial at. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespaceEigen.html#aadbf059bc28ce1cf94c57c1454633d40">poly_eval_horner()</a>.</p>

</div>
</div>
<a id="aadbf059bc28ce1cf94c57c1454633d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadbf059bc28ce1cf94c57c1454633d40">&#9670;&nbsp;</a></span>poly_eval_horner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Eigen::poly_eval_horner </td>
          <td>(</td>
          <td class="paramtype">const Polynomials &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the evaluation of the polynomial at x using Horner algorithm.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poly</td><td>: the vector of coefficients of the polynomial ordered by degrees i.e. poly[i] is the coefficient of degree i of the polynomial e.g. <img class="formulaInl" alt="$ 1 + 3x^2 $" src="form_22.png"/> is stored as a vector <img class="formulaInl" alt="$ [ 1, 0, 3 ] $" src="form_23.png"/>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: the value to evaluate the polynomial at.</td></tr>
  </table>
  </dd>
</dl>
<p><em><b>Note for stability:</b></em>  <img class="formulaInl" alt="$ |x| \le 1 $" src="form_24.png"/>  </p>

<p class="reference">Referenced by <a class="el" href="namespaceEigen.html#adb64ffddaa9e83634e3ab0e3fd3664f5">poly_eval()</a>.</p>

</div>
</div>
<a id="afbc3648f7ef67db3d5d04454fc1257fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc3648f7ef67db3d5d04454fc1257fd">&#9670;&nbsp;</a></span>roots_to_monicPolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::roots_to_monicPolynomial </td>
          <td>(</td>
          <td class="paramtype">const RootVector &amp;&#160;</td>
          <td class="paramname"><em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Polynomial &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the roots of a polynomial compute the coefficients in the monomial basis of the monic polynomial with same roots and minimal degree. If RootVector is a vector of complexes, Polynomial should also be a vector of complexes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rv</td><td>: a vector containing the roots of a polynomial. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">poly</td><td>: the vector of coefficients of the polynomial ordered by degrees i.e. poly[i] is the coefficient of degree i of the polynomial e.g. <img class="formulaInl" alt="$ 3 + x^2 $" src="form_25.png"/> is stored as a vector <img class="formulaInl" alt="$ [ 3, 0, 1 ] $" src="form_26.png"/>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceEigen.html">Eigen</a></li>
    <li class="footer">Generated on Tue Mar 12 2019 14:23:22 for Eigen-unsupported by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
<!-- Matomo -->
<script type="text/javascript">
  var _paq = _paq || [];
  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//stats.sylphide-consulting.com/matomo/";
    _paq.push(['setTrackerUrl', u+'piwik.php']);
    _paq.push(['setSiteId', '20']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'piwik.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<noscript><p><img src="//stats.sylphide-consulting.com/matomo/piwik.php?idsite=20&rec=1" style="border:0;" alt="" /></p></noscript>
<!-- End Matomo Code -->
</body>
</html>
